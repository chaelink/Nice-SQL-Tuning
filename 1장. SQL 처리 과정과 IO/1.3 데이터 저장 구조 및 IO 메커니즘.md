io튜닝이 곧 sql 튜닝

SQL이 느린 이유 == 디스크 I/O 때문

데이터베이스 저장 구조
- 테이블 스페이스 : 세그먼트를 담는 콘테이너, 여러 개의 데이터파일로 구성됨
- 세그먼트 : 테이블, 인덱스처럼 데이터 저장공간이 필요한 오브젝트
- 익스텐트 : 공간을 확장하는 단위(테이블이나 인덱스를 적다가 공간이 부족해지면 테이블 스페이스로부터 익스텐트를 추가 할당 받음)
  - 연속된 블록들의 집합, 인접한 블록은 같은 익스텐트에 속한 블록을 말함
- 블록 : 사용자가 입력한 레코드를 실제로 저장하는 공간, 한 블록은 하나의 테이블이 독점
  - DBMS가 데이터를 읽고 쓰는 단위
  - 오라클에서 블록 기본 사이즈는 8KB = 8192바이트


세그먼트에 할당된 모든 익스텐트는 다른 데이터파일에 위치할 가능성이 높다.
  => 파일 경합을 줄이기 위해 DBMS가 데이터를 가능한 여러 데이터파일로 분산 저장하기 때문. 

<BR>

시퀀셜 액세스
- 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식
- 인덱스 리프 블록이 가진 앞뒤 주소값을 통해 앞뒤로 순차적으로 스캔

랜덤 액세스
- 논리적, 물리적인 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근

<BR>

DB 버퍼 캐시
- 데이터 캐시(디스크에서 읽은 데이터를 캐심해 둠 -> 같은 블록에 대한 반복적인 IO CALL 줄이기)
- Direct Patth I/O를 제외한 모든 블록  I/O는 버퍼 캐시 경유
- 해시 구조로 관리
- SGA 메모리 내의 공유 자원이므로 직렬화 메커니즘 필요(래치)

버퍼캐시 히트율(BCHR)
- 읽은 전체 블록 중에서 물리적인 디스크 i/o를 수반하지 않고 곧바로 메모리에서 찾은 비율
- (캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수) * 100
- = (1 - 물리적 I/O / 논리적 I/O) * 100
- BCHR이 높다고 효율적인 SQL은 아님


Single Block I/O 
- I/O CALL을 한 번에 한 블록씩 요청
- 인덱스를 이용하면 기본적으로 인덱스와 테이블 모두 Single Block I/O 방식 사용

Multiblock I/O
- 한 번에 여러 블록씩 요청
- 대용량 테이블을 FULL SCAN할 때, Multiblock I/O 단위를 크게 설정하면 성능이 좋아짐
- 익스텐트 경계를 넘지는 못함

<BR>

Table Full Scan
- 테이블 전체를 스캔

Index Range Scan
- 인덱스를 이용한 테이블 액세스

집계용 sql & 배치 프로그램
- Table Full Scan으로 유도하면 성능이 빨라짐
- 인덱스가 더 성능 저하 -> 랜덤 액세스 + Single Block I/O 가 발생하기 때문에
















