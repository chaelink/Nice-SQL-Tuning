### 4.3 해시 조인
1. Build 단계 : 작은 쪽 테이블을 읽어 해시 테이블(해시맵) 생성
2. Probe 단계 : 큰 쪽 테이블을 읽어 해시 테이블을 탐색하면서 조인

- 조인 컬럼을 해시 테이블 키 값으로 사용
- 해시 테이블은 PGA 영역의 Hash Area에 저장 + Temp -> 해시 조인이 빠른 이유
- 해시 테이블에는 조인 키값뿐만 아니라 SQL에 사용한 컬럼 **모두** 저장
- 결과가 조인 순서대로** 정렬되지 않음**(쿼리에 order by 가 있으면 실행계획에서 order 추가 필요)
- 대량 데이터 조인 시, 소트머지조인 < 해시조인이 더 빠름
  - 사전 준비작업에 의한 성능 차이
  - 소트머지 조인 : 양쪽 집합을 모두 정렬
  - 해시 조인 : 작은 집합 하나만 읽어서 해시맵 저장
- 작은 집합의 해시맵이 모두 PGA 해시 영역에 저장되는 **인메모리 해시 조인**이면 가장 효과적

<br>

인메모리 해시 조인 불가능 경우(대용량)
- 분할 정복 방법으로, 파티션 짝 생성
- 각 파티션 짝 별로, 작은 집합 큰집합을 독립적으로 결정 

<br>

해시 조인 사용 경우
- 수행 빈도가 낮고
- 쿼리 수행 시간이 오래 걸리는
- 대용량 데이터를 조인할 때
- (배치, DW, OLAP 프로그램)

<br>

세 개 이상 테이블의 해시 조인
- leading 힌트로 순서 지정
- Build Input으로 선택하고 싶으면 : swap_join_inputs
- Probe Input으로 선택하고 싶으면 : no_swap_join_inputs

<br>

일반적인 조인 메소드 선택 기준
- 소량 데이터 조인 : NL 조인
- 대량 데이터 조인 : 해시 조인
- 대량 데이터, 등치 조건이 아닐 때 : 소트머지 조인

<br>

수행빈도가 높은 쿼리
- NL 조인 선택
- NL 조인보다 해시 조인이 매우 빠른 경우에만, 해시 조인

이유
- NL조인에 사용하는 인덱스는 영구적으로 유지되며 이후 공유, 재사용 가능
- 해시조인은 한번의 실행을 위해 각각의 해시 맵 생성 -> CPU 및 메모리 사용 증가, 래치 경합 발생 가능

---
### 헷갈리는 내용
- '래치 획득 및 캐시버퍼 체인 스캔' 중 캐시버퍼 체인 스캔 자세한 과정
  - 캐시 버퍼 체인 스캔이란, 버퍼 캐시에서 특정 데이터 블록을 찾기 위해 해시 체인에 연결된 버퍼 헤더들을 순차적으로 탐색하는 과정
- 캐시버퍼와 버퍼캐시는 다르다
  - 버퍼캐시는 sga 메모리 내의 공유 자원,
  - 캐시 버퍼는 ... 
- 해시 조인에서 옵티마이저가 빌드 인풋을 고를 때, 보통 카디널리티가 작은 테이블을 선택한다. 왜?
  - 해시 조인의 빌드 인풋은 PGA에 해시 테이블을 생성하므로, 메모리 사용량과 처리 비용을 최소화하기 위해 카디널리티가 작은 테이블을 선택한다.
- 해시맵은 PGA의 해시 영역에 저장, 래치 경합이 왜 발생할까, 해시맵을 만드는 과정 중 빌드 집합을 읽을 땐 인덱스를 사용해서 버퍼캐시를 경유하기 때문?
  - 해시 테이블이 PGA에 있어도, 해시 테이블을 만들기 위한 데이터는 버퍼 캐시를 통해 읽기 때문에 그 과정에서 래치 경합이 발생할 수 있다 
- 293쪽 세 개 이상 테이블에서 빌드 인풋 선택 등 힌트 지정 방식 다시 읽어보기
- 카디널리티가 작다가 무슨 뜻?
