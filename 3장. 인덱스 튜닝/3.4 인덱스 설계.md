### 3.4 인덱스 설계

인덱스가 많으면 발생하는 문제들
- DML 성능 저하 -> TPS 저하
- 데이터베이스 사이즈 증가 -> 디스크 공간 낭비
- 데이터베이스 관리 및 운영 비용 상승

인덱스 구성 기준(판단 기준 : 인덱스 스캔 효율성)
- 조건절에 항상 사용하거나, 자주 사용하는 컬럼 선정
- '=' 조건으로 자주 조회하는 컬럼을 앞쪽에 둔다

그 외의 판단 기준
- 수행 빈도(가장 중요)
- 업무상 중요도
- 클러스터링 팩터
- 데이터량
- DML 부하
- 저장 공간
- 인덱스 관리 비용 등

<br>

I/O를 최소화하면서 소트 연산 생략하는 인덱스 구성 방법
- '=' 연산자로 사용한 조건절 컬럼 선정
- ORDER BY 절에 기술한 컬럼 추가
- '=' 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정

IN 조건에 대하여
- 소트 연산을 생략하려면 IN 조건절이 IN LIST ITERATOR 방식으로 풀리면 안된다
- IN 조건절을 액세스 조건이 아닌 필터 조건으로 사용해야 함
- 즉, 인덱스 구성 시 order by 컬럼보다 뒤쪽에 두어야 함

<br>

선택도 : 전체 레코드 중 조건절에 의해 선택되는 레코드 비율
- 선택도가 충분히 낮은지가 인덱스 생성여부 판단기준
- 선택도 * 총 레코드 수 = 카디널리티
- 선택도가 높은, 카디널리티가 높은 인덱스는 생성해도 효용가치가 낮음

<br>

중복 인덱스 제거
- 완전 중복 : 한 인덱스가 다른 인덱스에 모두 포함되는 경우
  - 포함되는 인덱스 제거 
- 불완전 중복 : 선두 컬럼은 같지만 두번째 컬럼이 모두 다른 경우
  - 선두 컬럼의 평균 카디날리티가 낮다면, 사실상 중복
  - 각 인덱스의 두번째 컬럼을 모두 합체



----
헷갈리는 개념
- '=' 이 아닌 조건절 컬럼은, order by 컬럼보다 뒤쪽에 두어야 소트 연산 생략이 가능하다
  - 앞쪽에 두면 결과가 어떻게 달라지는지?
 

 
