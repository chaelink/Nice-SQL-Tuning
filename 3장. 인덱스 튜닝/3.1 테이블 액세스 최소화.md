sql 튜닝은 랜덤 io와의 전쟁이다.

#### 3.1.1 테이블 랜덤 액세스

인덱스 ROWID : 테이블 레코드를 찾아가기 위한 주소값
- 논리적 주소
  - 물리적으로 직접 연결되지 않고, 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있기 때문에
- BUT, 데이터 파일 번호, 블록 번호 같은 물리적 요소로 구성되어 있긴 함.
- 포인터와 다름
- ROWID를 분해해서 DBA 정보를 얻고, 버퍼캐시 조회 후 디스크 조회
  - 이 과정에서 발생하는 DBA 해싱과 래치 획득에 상당히 고비용 발생
  - 따라서, 'ROWID에 의한 테이블 액세스'는 고비용 연산임을 기억해야 함.
 
<br>

메인 메모리 DB(MMDB) : 모든 데이터를 모두 메모리에 올리는 DB
- 인덱스가 메모리 상의 주소 정보, 즉 포인터를 갖음(디스크 상의 주소정보가 아닌)
- 따라서 오라클과 비교할 수 없을 만큼 빠르다

#### 3.1.2 인덱스 클러스터링 팩터(군집성 계수, CF)

인덱스 클러스터링 팩터(군집성 계수)
- 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도
- CF가 좋은 컬럼에 생성한 인덱스는 검색 효율이 매우 좋다.
  - = 테이블 액세스량에 비해 블록 I/O가 적게 발생함
  - 인덱스 ROWID로 테이블에 액세스한 후 얻은 포인터를 저장함 (버퍼 Pinning)
  - 이후 다음 인덱스가 같은 블록을 가리키면 바로 테이블 블록 조회 가능
- 인덱스 클러스터링 팩터가 가장 좋은 상태 = 인덱스 레코드 정렬 순서와 테이블 레코드 정렬 순서가 100% 일치하는 것

#### 3.1.3 인덱스 손익분기점

인덱스 손익분기점
- Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점
- 보통 인덱스 손익분기점은 (5 ~ 20%) 수준
- CF에 따라 크게 달라짐(CF가 나쁘면 손익분기점도 낮고, 높으면 높음)


Index Range Scan이  Table Full Scan보다 느려지는 핵심 요인
- 랜덤액세스 방식임. (table은 시퀀셜 액세스)
- Single Block IO임 (table은 Multiblock IO 방식)

<br>

온라인 프로그램(OLTP)
- 보통 소량 데이터를 읽고 갱신 -> 인덱스의 효율적 활용이 중요
- NL조인
- 부분범위 처리 방식으로 구현 가능

배치, DW, OLAP 프로그램
- 대량 데이터를 읽고 갱신
- 해시 조인, Full Scan
- 항상 전체범위 처리
- 초대용량 배치 프로그램 : 파티션 활용 전략, 병렬 처리가 중요


#### 3.1.4 인덱스 컬럼 추가

인덱스 컬럼 추가
- 테이블 액세스 최소화를 위해 가장 일반적으로 사용하는 튜닝 기법
- 테이블 액세스 수 > 결과 집합 수 이면, 테이블 조회 후 필터링 되는 값이 많은 비효율 상황
  - 인덱스 컬럼을 추가해서 테이블 액세스 수를 줄이기 


#### 3.1.5 인덱스만 읽고 처리

Covered 쿼리
- 인덱스만 읽어서 처리하는 쿼리
- 테이블 액세스가 아예 발생하지 않음
- Covered 인덱스 사용

Include 인덱스
- 오라클에는 아직 없음, SQL Server 2005 버전에 추가된 기능
- 인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능
- 테이블 랜덤 액세스를 줄이는 용도
- 인덱스 생성 시 include 옵션으로 지정, 컬럼 최대 1023개까지 지정 가능


#### 3.1.6 인덱스 구조 테이블


IOT(Index-Organized Table) == 클러스터형 인덱스
- 테이블을 인덱스 구조로 생성
- 테이블 블록에 있어야 할 데이터를 인덱스 리프 블록에 모두 저장
- 인덱스 리프 블록이 곧 데이터 블록
- `organization index;`
- 시퀀셜 방식으로 데이터 액세스 -> between 이나 부등호 조건으로 넓은 범위를 읽을 때 유리


#### 3.1.7 클러스터 테이블

클러스터 테이블이란
- 데이터베이스에서 성능 향상을 위해 관련된 테이블의 데이터를 물리적으로 같은 저장 공간(블록)에 모아서 저장하는 기법

클러스터 테이블
- 인덱스 클러스터 테이블
  - 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조
  - 한 블록에 모두 담을 수 없으면, 새 블록에 할당해서 클러스터 체인으로 연결
  - 다중 테이블 클러스터 : 여러 테이블 레코드를 같은 블록에 저장
  -  `create cluster index;`
- 해시 클러스터 테이블
  - 인덱스를 사용하지 않고, 해시 알고리즘을 사용해 클러스터를 찾아감
  - `create cluster hashkeys n;`

-----------

### 헷갈리는 용어 모음
- 인덱스 클러스터링 팩터 : 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도
- 클러스터형 인덱스(IOT) : 테이블을 인덱스 구조로 생성
- 클러스터 테이블 : 데이터베이스에서 성능 향상을 위해 관련된 테이블의 데이터를 물리적으로 같은 저장 공간(블록)에 모아서 저장하는 기법







