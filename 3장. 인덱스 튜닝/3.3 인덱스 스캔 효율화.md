### 3.3 인덱스 스캔 효율화

- SQL트레이스 : 인덱스 스캔 효율 측정 방법

<br>

- 인덱스 액세스 조건 : 인덱스 스캔 범위를 결정하는 조건절
  - 인덱스 수직적 탐색을 통해 스캔 시작점 결정에 영향
  - 인덱스 리프 블록을 스캔하다가 어디서 멈출지를 결정하는데 영향을 미침 
- 인덱스 필터 조건 : 테이블로 액세스할 지를 결정하는 조건절
- 테이블 필터 조건 : 쿼리 수행 다음 단계로 전달하거나 최종 결과 집합에 포함할지 결정

<br>

- 선행 컬럼이 모두 '=' 조건인 상태에서, 첫번째로 나타나는 범위검색 조건이 인덱스 스캔 범위를 결정한다.(인덱스 액세스 조건)


인덱스를 이용한 테이블 액세스 비용
- 인덱스 수직적 탐색 비용 +
- 인덱스 수평적 탐색 비용 +
- 테이블 랜덤 액세스 비용

<br>

인덱스 선행 컬럼이 등치 조건이 아닐 때의 비효율
- 인덱스 선행 컬럼이 조건절에 없거나
- between, like 같은 범위검색 조건이면
- => 인덱스 스캔 단계에서 비효율 발생

<br>

BETWEEN을 IN-List로 전환
- in 요소 갯수만큼 수직적 탐색 진행 + union all로 계산
- 조건을 만족하는 레코드가 서로 멀리 떨어져 있을 때 유용

<br>

Index Skip Scan 활용
- Index 선두 컬럼이 조건절에 없어도 Index를 활용하는 새로운 스캔 방식
- BETWEEN을 IN-List로 전환하면 도움이 되는 상황에서, '조건절'을 바꾸지 않고도 같은 효과를 내는 방법

<br>

IN 조건은 '='인가? (아님)
- IN-List Iterator 방식으로 풀려야만 IN 조건이 '='임
- 그렇지 않으면, IN 조건은 필터 조건이다.

<br>

BETWEEN과 LIKE 스캔 범위 비교
- LIKE 보다 BETWEEN이 낫다

#### 3.3.10 범위검색 조건을 남용할 때 생기는 비효율
- 인덱스 컬럼에 범위 검색 조건을 남용하면, 인덱스 스캔 비효율 발생

or 조건 활용
- 인덱스 선두 컬럼에 대한 옵션 조건에 or조건을 사용하면 안 된다.
- or조건을 활용한 옵션 조건 처리
  - 인덱스 액세스 조건으로 사용 불가
  - 인덱스 필터 조건으로 사용 불가
  - 테이블 필터 조건으로만 사용 가능
  - 단, 인덱스 구성 컬럼 중 하나 이상이 not null이면 18c부터 인덱스 필터 조건으로 사용 가능SQL트레이스 : 인덱스 스캔 효율 측정 방법

<br>

- 인덱스 액세스 조건 : 인덱스 스캔 범위를 결정하는 조건절
  - 인덱스 수직적 탐색을 통해 스캔 시작점 결정에 영향
  - 인덱스 리프 블록을 스캔하다가 어디서 멈출지를 결정하는데 영향을 미침 
- 인덱스 필터 조건 : 테이블로 액세스할 지를 결정하는 조건절
- 테이블 필터 조건 : 쿼리 수행 다음 단계로 전달하거나 최종 결과 집합에 포함할지 결정

<br>

- 선행 컬럼이 모두 '=' 조건인 상태에서, 첫번째로 나타나는 범위검색 조건이 인덱스 스캔 범위를 결정한다.(인덱스 액세스 조건)


인덱스를 이용한 테이블 액세스 비용
- 인덱스 수직적 탐색 비용 +
- 인덱스 수평적 탐색 비용 +
- 테이블 랜덤 액세스 비용

<br>

인덱스 선행 컬럼이 등치 조건이 아닐 때의 비효율
- 인덱스 선행 컬럼이 조건절에 없거나
- between, like 같은 범위검색 조건이면
- => 인덱스 스캔 단계에서 비효율 발생

<br>

BETWEEN을 IN-List로 전환
- in 요소 갯수만큼 수직적 탐색 진행 + union all로 계산
- 조건을 만족하는 레코드가 서로 멀리 떨어져 있을 때 유용

<br>

Index Skip Scan 활용
- Index 선두 컬럼이 조건절에 없어도 Index를 활용하는 새로운 스캔 방식
- BETWEEN을 IN-List로 전환하면 도움이 되는 상황에서, '조건절'을 바꾸지 않고도 같은 효과를 내는 방법

<br>

IN 조건은 '='인가? (아님)
- IN-List Iterator 방식으로 풀려야만 IN 조건이 '='임
- 그렇지 않으면, IN 조건은 필터 조건이다.

<br>

BETWEEN과 LIKE 스캔 범위 비교
- LIKE 보다 BETWEEN이 낫다

#### 3.3.10 범위검색 조건을 남용할 때 생기는 비효율
- 인덱스 컬럼에 범위 검색 조건을 남용하면, 인덱스 스캔 비효율 발생

or 조건 활용
- 인덱스 선두 컬럼에 대한 옵션 조건에 or조건을 사용하면 안 된다.
- or조건을 활용한 옵션 조건 처리
  - 인덱스 액세스 조건으로 사용 불가
  - 인덱스 필터 조건으로 사용 불가
  - 테이블 필터 조건으로만 사용 가능
  - 단, 인덱스 구성 컬럼 중 하나 이상이 not null이면 18c부터 인덱스 필터 조건으로 사용 가능

LIKE/BETWEEN 조건 활용
- 변별력 좋은 필수 조건(인덱스 액세스 조건)이 있으면 사용하기 좋음
- 아래 경우에 속하는지 확인 필요
1. 인덱스 선두 컬럼
- 인덱스 선두 컬럼에 대한 옵션 조건을 LIKE/BETWEEN 연산자로 처리하는 것은 금물
2. NULL 허용 컬럼
- NULL 허용 컬럼에 대한 옵션 조건을 LIKE/BETWEEN 연산자로 처리하는 것은 금물
- 결과 집합에 오류가 생김

3. 숫자형 컬럼
- 숫자형이면서 인덱스 액세스 조건으로 사용 가능한 컬럼에 대한 옵션 조건 처리는 like 방식 사용 금물
4. 가변 길이 컬럼
- like를 옵션 조건에 사용할 때는 컬럼 값 길이가 고정적이어야 함

UNION ALL 활용


NVL/DECODE 함수 활용 이용한 테이블 액세스 비용
- 인덱스 수직적 탐색 비용 +
- 인덱스 수평적 탐색 비용 +
- 테이블 랜덤 액세스 비용

<br>

인덱스 선행 컬럼이 등치 조건이 아닐 때의 비효율
- 인덱스 선행 컬럼이 조건절에 없거나
- between, like 같은 범위검색 조건이면
- => 인덱스 스캔 단계에서 비효율 발생

<br>

BETWEEN을 IN-List로 전환
- in 요소 갯수만큼 수직적 탐색 진행 + union all로 계산
- 조건을 만족하는 레코드가 서로 멀리 떨어져 있을 때 유용

<br>

Index Skip Scan 활용
- Index 선두 컬럼이 조건절에 없어도 Index를 활용하는 새로운 스캔 방식
- BETWEEN을 IN-List로 전환하면 도움이 되는 상황에서, '조건절'을 바꾸지 않고도 같은 효과를 내는 방법

<br>

IN 조건은 '='인가? (아님)
- IN-List Iterator 방식으로 풀려야만 IN 조건이 '='임
- 그렇지 않으면, IN 조건은 필터 조건이다.

<br>

BETWEEN과 LIKE 스캔 범위 비교
- LIKE 보다 BETWEEN이 낫다

<br>

#### 3.3.10 범위검색 조건을 남용할 때 생기는 비효율
- 인덱스 컬럼에 범위 검색 조건을 남용하면, 인덱스 스캔 비효율 발생

or 조건 활용
- 인덱스 선두 컬럼에 대한 옵션 조건에 or조건을 사용하면 안 된다.
- or조건을 활용한 옵션 조건 처리
  - 인덱스 액세스 조건으로 사용 불가
  - 인덱스 필터 조건으로 사용 불가
  - 테이블 필터 조건으로만 사용 가능
  - 단, 인덱스 구성 컬럼 중 하나 이상이 not null이면 18c부터 인덱스 필터 조건으로 사용 가능

LIKE/BETWEEN 조건 활용
- 변별력 좋은 필수 조건(인덱스 액세스 조건)이 있으면 사용하기 좋음
- 아래 경우에 속하는지 확인 필요
1. 인덱스 선두 컬럼
- 인덱스 선두 컬럼에 대한 옵션 조건을 LIKE/BETWEEN 연산자로 처리하는 것은 금물
2. NULL 허용 컬럼
- NULL 허용 컬럼에 대한 옵션 조건을 LIKE/BETWEEN 연산자로 처리하는 것은 금물
- 결과 집합에 오류가 생김

3. 숫자형 컬럼
- 숫자형이면서 인덱스 액세스 조건으로 사용 가능한 컬럼에 대한 옵션 조건 처리는 like 방식 사용 금물
- 자동 형 변환을 통해 액세스 조건이 필터 조건이 되기 때문
4. 가변 길이 컬럼
- like를 옵션 조건에 사용할 때는 컬럼 값 길이가 고정적이어야 함

UNION ALL 활용
- 인덱스를 가장 최적으로 사용 가능
- 옵션 조건 컬럼을 인덱스 액세스 조건으로 사용 가능


NVL/DECODE 함수 활용
- or expansion 쿼리 변환을 통해, UNION ALL 방식으로 옵티마이저가 쿼리를 변환함
- 옵션 조건 컬럼을 인덱스 액세스 조건으로 사용 가능
- 옵션 조건용 NVL/DECODE 함수를 여러 개 사용하면, 그 중 가장 변별력이 좋은 컬럼 기준으로 한번만 or expansion이 일어남
- or expansion 기준으로 선택되지 않으면 인덱스 구성 컬럼이어도 필터 조건으로 처리됨

<br>

#### 3.3.12 함수호출부하 해소를 위한 인덱스 구성

PL/SQL 사용자 정의 함수가 느린 이유
- 가상머신 상에서 실행되는 인터프리터 언어
- 호출 시마다 컨텍스트 스위칭 발생
- 내장 SQL에 대한 Recursive call 발생

PL/SQL 특징
- java와 같은 인터프리터 언어로, native 코드에 비해 느리다


---
### 헷갈리는 내용
- 카디널리티? 선택도?
- IN-List 와 IN-List Iterator 방식은 다른 것?(책에 포스트잇 같이 볼 것)
- or expansion이 무엇인지
  -  데이터베이스(특히 오라클)에서 SQL 쿼리의 WHERE 절에 있는 OR 또는 IN 조건을 UNION ALL 형태로 변환하여,
  -  각 조건별로 인덱스를 사용하여 최적의 액세스 경로(Index Range Scan)를 찾도록 돕는 쿼리 최적화 기법 
- 필수 조건 vs 옵션 조건
- 다이나믹 sql이 아니면 옵션 조건에 = 연산자 사용 불가?



