### 3.3 인덱스 스캔 효율화

- SQL트레이스 : 인덱스 스캔 효율 측정 방법

<br>

- 인덱스 액세스 조건 : 인덱스 스캔 범위를 결정하는 조건절
  - 인덱스 수직적 탐색을 통해 스캔 시작점 결정에 영향
  - 인덱스 리프 블록을 스캔하다가 어디서 멈출지를 결정하는데 영향을 미침 
- 인덱스 필터 조건 : 테이블로 액세스할 지를 결정하는 조건절
- 테이블 필터 조건 : 쿼리 수행 다음 단계로 전달하거나 최종 결과 집합에 포함할지 결정

<br>

- 선행 컬럼이 모두 '=' 조건인 상태에서, 첫번째로 나타나는 범위검색 조건이 인덱스 스캔 범위를 결정한다.(인덱스 액세스 조건)


인덱스를 이용한 테이블 액세스 비용
- 인덱스 수직적 탐색 비용 +
- 인덱스 수평적 탐색 비용 +
- 테이블 랜덤 액세스 비용

<br>

인덱스 선행 컬럼이 등치 조건이 아닐 때의 비효율
- 인덱스 선행 컬럼이 조건절에 없거나
- between, like 같은 범위검색 조건이면
- => 인덱스 스캔 단계에서 비효율 발생

<br>

BETWEEN을 IN-List로 전환
-in 요소 갯수만큼 수직적 탐색 진행 + union all로 계산
조건을 만족하는 레코드가 서로 멀리 떨어져 있을 때 유용

<br>

Index Skip Scan 활용
- Index 선두 컬럼이 조건절에 없어도 Index를 활용하는 새로운 스캔 방식
- BETWEEN을 IN-List로 전환하면 도움이 되는 상황에서, '조건절'을 바꾸지 않고도 같은 효과를 내는 방법

<br>

IN 조건은 '='인가? (아님)
- IN-List Iterator 방식으로 풀려야만 IN 조건이 '='임
- 그렇지 않으면, IN 조건은 필터 조건이다.

<br>

BETWEEN과 LIKE 스캔 범위 비교
- LIKE 보다 BETWEEN이 낫다

211페이지부터 이어서





---
### 헷갈리는 내용
- 카디널리티? 선택도?
- IN-List 와 IN-List Iterator 방식은 다른 것?(책에 포스트잇 같이 볼 것)
















